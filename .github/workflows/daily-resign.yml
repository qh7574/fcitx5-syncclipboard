name: Daily Resign Fcitx5 Android

on:
  schedule:
    # 每天 UTC 时间 00:00 运行 (北京时间 08:00)
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      source:
        description: 'Artifact Source (release / ci)'
        required: true
        default: 'ci'
        type: choice
        options:
          - release
          - ci

jobs:
  resign-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 允许创建 Release
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Android SDK Build Tools
        uses: android-actions/setup-android@v3

      # 移除 Apktool 安装步骤，因为纯重签名不需要反编译

      - name: Download Artifacts
        id: download
        uses: actions/github-script@v7
        env:
          SOURCE_TYPE: ${{ inputs.source || 'ci' }} # 默认为 ci (如果是 schedule 触发)
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const owner = 'fcitx5-android';
            const repo = 'fcitx5-android';
            const sourceType = process.env.SOURCE_TYPE;
            
            console.log(`Fetching artifacts from: ${sourceType}`);
            
            let versionTag = '';
            
            if (sourceType === 'release') {
              // === Release 逻辑 ===
              const release = await github.rest.repos.getLatestRelease({ owner, repo });
              versionTag = release.data.tag_name;
              console.log('Latest release tag:', versionTag);
              
              const assets = release.data.assets.filter(asset => asset.name.endsWith('.apk'));
              if (assets.length === 0) throw new Error('No APK found in release');
              
              let downloadScript = '';
              for (const asset of assets) {
                console.log(`Queueing download: ${asset.name}`);
                downloadScript += `wget -O "${asset.name}" "${asset.browser_download_url}"\n`;
              }
              fs.writeFileSync('download_apks.sh', downloadScript);
              
            } else {
              // === CI 逻辑 ===
              // 1. 获取最新成功的 Workflow Run (通常是 'Build' 或 'CI')
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                status: 'completed',
                conclusion: 'success',
                branch: 'master', // 或 main，fcitx5-android 似乎是用 master
                per_page: 1
              });
              
              if (runs.data.workflow_runs.length === 0) throw new Error('No successful runs found');
              
              const latestRun = runs.data.workflow_runs[0];
              console.log(`Latest Run ID: ${latestRun.id}, Commit: ${latestRun.head_sha}`);
              
              // 使用日期+commit hash 作为版本号
              const date = new Date(latestRun.created_at).toISOString().split('T')[0];
              versionTag = `ci-${date}-${latestRun.head_sha.substring(0, 7)}`;
              
              // 2. 获取 Artifacts
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner,
                repo,
                run_id: latestRun.id
              });
              
              // 3. 下载所有 APK 相关的 Artifacts
              // 通常 artifact 名字包含 'apk', 'release', 'debug', 'app' 或 'fdroid'
              const targetArtifacts = artifacts.data.artifacts.filter(a => 
                !a.expired && (a.name.includes('apk') || a.name.includes('release') || a.name.includes('debug') || a.name.includes('app') || a.name.includes('fdroid'))
              );
              
              if (targetArtifacts.length === 0) {
                 const available = artifacts.data.artifacts.map(a => a.name).join(', ');
                 console.log("Available artifacts:", available);
                 throw new Error(`No relevant artifacts found in the latest run. Available: ${available}`);
              }
              
              for (const artifact of targetArtifacts) {
                console.log(`Downloading artifact: ${artifact.name} (${artifact.id})`);
                const download = await github.rest.actions.downloadArtifact({
                  owner,
                  repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip',
                });
                
                fs.writeFileSync(`${artifact.name}.zip`, Buffer.from(download.data));
                // 解压 zip
                // 注意：这里只是写入 zip，后续步骤统一解压
              }
            }
            
            core.setOutput('version_tag', versionTag);

      - name: Prepare APKs
        run: |
          # 如果是 Release 模式，运行生成的下载脚本
          if [ -f download_apks.sh ]; then
            bash download_apks.sh
          fi
          
          # 如果是 CI 模式，解压所有 zip 并重命名 APK 为 artifact 名称
          # 这样最终生成的 APK 将会是 artifact_name-resigned.apk
          # 例如: fdroid-arm64-v8a.zip -> fdroid-arm64-v8a.apk -> fdroid-arm64-v8a-resigned.apk
          for zip in *.zip; do
            if [ -f "$zip" ]; then
              artifact_name=$(basename "$zip" .zip)
              echo "Processing artifact: $artifact_name"
              
              # 创建临时目录解压，防止文件名冲突
              mkdir -p "temp_$artifact_name"
              unzip -q "$zip" -d "temp_$artifact_name"
              
              # 找到解压出的 APK (假设每个 artifact 只有一个主要 APK)
              found_apk=$(find "temp_$artifact_name" -name "*.apk" | head -n 1)
              
              if [ -n "$found_apk" ]; then
                echo "Found APK: $found_apk"
                # 重命名为 artifact_name.apk 并移动到当前目录
                mv "$found_apk" "./${artifact_name}.apk"
                echo "Renamed to: ${artifact_name}.apk"
              else
                echo "Warning: No APK found in $zip"
              fi
              
              # 清理
              rm -rf "temp_$artifact_name"
              rm "$zip"
            fi
          done

      - name: Decode Keystore
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
        run: |
          if [ -z "$KEYSTORE_BASE64" ]; then
            echo "Error: KEYSTORE_BASE64 secret is not set."
            exit 1
          fi
          echo "$KEYSTORE_BASE64" | base64 -d > signing_key.jks

      - name: Process APKs (Zipalign & Resign)
        env:
          BUILD_TOOLS_VERSION: "34.0.0"
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        run: |
          # 查找 build-tools 路径
          BUILD_TOOLS_PATH=$ANDROID_HOME/build-tools/$BUILD_TOOLS_VERSION
          if [ ! -d "$BUILD_TOOLS_PATH" ]; then
            BUILD_TOOLS_PATH=$(ls -d $ANDROID_HOME/build-tools/* | tail -1)
          fi
          echo "Using Build Tools at: $BUILD_TOOLS_PATH"
          ZIPALIGN="$BUILD_TOOLS_PATH/zipalign"
          APKSIGNER="$BUILD_TOOLS_PATH/apksigner"
          
          mkdir -p resigned_apks
          
          for apk in *.apk; do
            echo "---------------------------------------------------"
            echo "Processing $apk ..."
            base_name=$(basename "$apk" .apk)
            aligned_apk="aligned_${base_name}.apk"
            signed_apk="${base_name}-resigned.apk"
            
            # 1. Zipalign
            # 直接对下载的 APK 进行对齐，无需解包
            echo "Aligning..."
            "$ZIPALIGN" -p -f -v 4 "$apk" "$aligned_apk"
            
            # 2. Sign
            # 对齐后的 APK 进行签名
            echo "Signing..."
            "$APKSIGNER" sign --ks signing_key.jks \
              --ks-key-alias "$KEY_ALIAS" \
              --ks-pass "pass:$KEYSTORE_PASSWORD" \
              --key-pass "pass:$KEY_PASSWORD" \
              --out "resigned_apks/$signed_apk" \
              "$aligned_apk"
              
            # 验证
            "$APKSIGNER" verify "resigned_apks/$signed_apk"
            
            # Clean up temp files
            rm "$aligned_apk"
          done

      - name: Create Pre-release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.download.outputs.version_tag }}
          name: Resigned Build ${{ steps.download.outputs.version_tag }}
          files: resigned_apks/*.apk
          prerelease: true
          body: |
            Automated resigned build from fcitx5-android ${{ inputs.source || 'ci' }}.
            Original Source: fcitx5-android/fcitx5-android
